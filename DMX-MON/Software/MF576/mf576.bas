
'***************************************************
'* MF576
'* Controller DMX 8ch
'* 
'* Il sistema è basato su un PIC16F876 lavorante a 20 MHz
'* Ultimo aggiornamento 7/12/2004 
'******************************************************************************

DEFINE OSC 20
@		DEVICE HS_OSC

'Configurazione usart 250000
DEFINE HSER_BITS 9
DEFINE HSER_RCSTA 208 
DEFINE HSER_TXSTA 101
DEFINE HSER_BAUD 250000
DEFINE HSER_CLROERR 1 'Hser clear overflow automatically 

'Debug
DEFINE DEBUG_REG PORTC
DEFINE DEBUG_BIT 1
DEFINE DEBUG_BAUD 9600  
DEFINE DEBUG_MODE 0  

SYMBOL  IN       =PORTC.0
SYMBOL	LED      =PORTC.3		'LED
SYMBOL	SDA      =PORTA.2		'SDA TDA8444 OUT ANALOGICHE ESTERNE
SYMBOL	SCL      =PORTA.3		'SCL TDA8444 OUT ANALOGICHE ESTERNE

INPUT	IN

TMP             VAR     WORD
TMP1            VAR     WORD
VALORE          VAR     byte[65]
BREAK           VAR     WORD
NDMX            VAR     WORD
DATI            VAR     WORD
Clear

ADCON0=0
ADCON1=7
OPTION_REG.7=0	'Abilita resistenze di pull-up
FOR TMP=0 TO 10
    TOGGLE LED
    PAUSE 200
NEXT TMP


MAIN:
LOW LED
NDMX=0
'NDMX=PORTB
NDMX.0=PORTA.1
NDMX.1=PORTA.0
NDMX.2=PORTB.7
NDMX.3=PORTB.6
NDMX.4=PORTB.5
NDMX.5=PORTB.4
NDMX.6=PORTB.3
NDMX.7=PORTB.2
NDMX.8=PORTB.1
NDMX.9=PORTB.0

ndmx = ndmx ^ %0000001111111111
DEBUG "NDMX ",#NDMX,10,13
DATI=0
PULSIN in,0,break

IF BREAK>=40 THEN
    high led
    HSERIN 2000,MAIN,[tmp,tmp1]
    if tmp<>0 and tmp1<>0 then
        goto main
    endif
    
    FOR TMP=1 TO ndmx
        HSERIN 10,main,[tmp1]
'        'DEBUG "tmp ",#tmp,13,10
    NEXT TMP
        
        'hserin 10,main,[STR VALORE \9 ]
        FOR tmp=1 TO 64    
            
            hserin 10,EXIT,[VALORE[tmp]]
            DATI=DATI+1
        NEXT TMP

EXIT:   
            FOR TMP=1 TO DATI
                DEBUG "VALORE",#tmp, " -> ",#VALORE[tmp],13,10
                VALORE[TMP]=VALORE[TMP]/4                                                   
            NEXT TMP

    I2CWRITE SDA,SCL,%01000000,%00000000,[VALORE[1],VALORE[2],VALORE[3],VALORE[4],VALORE[5],VALORE[6],VALORE[7],VALORE[8]]
    I2CWRITE SDA,SCL,%01000010,%00000000,[VALORE[9],VALORE[10],VALORE[11],VALORE[12],VALORE[13],VALORE[14],VALORE[15],VALORE[16]]
    I2CWRITE SDA,SCL,%01000100,%00000000,[VALORE[17],VALORE[18],VALORE[19],VALORE[20],VALORE[21],VALORE[22],VALORE[23],VALORE[24]]    
    I2CWRITE SDA,SCL,%01000110,%00000000,[VALORE[25],VALORE[26],VALORE[27],VALORE[28],VALORE[29],VALORE[30],VALORE[31],VALORE[32]]
    I2CWRITE SDA,SCL,%01001000,%00000000,[VALORE[33],VALORE[34],VALORE[35],VALORE[36],VALORE[37],VALORE[38],VALORE[39],VALORE[40]]
    I2CWRITE SDA,SCL,%01001010,%00000000,[VALORE[41],VALORE[42],VALORE[43],VALORE[44],VALORE[45],VALORE[46],VALORE[47],VALORE[48]]
    I2CWRITE SDA,SCL,%01001100,%00000000,[VALORE[49],VALORE[50],VALORE[51],VALORE[52],VALORE[53],VALORE[54],VALORE[55],VALORE[56]]
    I2CWRITE SDA,SCL,%01001110,%00000000,[VALORE[57],VALORE[58],VALORE[59],VALORE[60],VALORE[61],VALORE[62],VALORE[63],VALORE[64]]
    'PAUSE 5
       
ENDIF


GOTO MAIN

USCITE:

            'FOR TMP=1 TO 8
                
            '    IF VALORE[TMP]>63 THEN
            '        VALORE[TMP]=63
            '    ENDIF
            '    DEBUG "VALORE ",#VALORE[tmp],13,10
                
            'NEXT TMP
            'PAUSE 500
            'OUT = %11110000 + OUT
            
            I2CWRITE SDA,SCL,%01000000,%00000000,[VALORE[1],VALORE[2],VALORE[3],VALORE[4],VALORE[5],VALORE[6],VALORE[7],VALORE[8]]
            I2CWRITE SDA,SCL,%01000000,%00000000,[VALORE[1],VALORE[2],VALORE[3],VALORE[4],VALORE[5],VALORE[6],VALORE[7],VALORE[8]]
            I2CWRITE SDA,SCL,%01000000,%00000000,[VALORE[1],VALORE[2],VALORE[3],VALORE[4],VALORE[5],VALORE[6],VALORE[7],VALORE[8]]



RETURN
